--[[
    Menu üíÄ Apocalypse Rising 2 üíÄ - v2.1 (Corre√ß√£o de Precis√£o)

    CR√âDITOS:
    - Criador: @keven_xz

    ALTERA√á√ïES NESTA VERS√ÉO:
    - CORRE√á√ÉO DE PRECIS√ÉO: A l√≥gica de mira foi refinada para ser mais precisa.
    - PREVIS√ÉO SIMPLIFICADA: As duas op√ß√µes de previs√£o foram unificadas num √∫nico e mais
      eficaz slider de "Previs√£o de Alvo" para facilitar o ajuste fino.
]]

-- =================================================================================
-- CARREGAMENTO DA BIBLIOTECA RAYFIELD E CONFIGURA√á√ÉO DA UI
-- =================================================================================
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "Menu üíÄ Apocalypse Rising 2 üíÄ",
   LoadingTitle = "A carregar Script...",
   LoadingSubtitle = "por @keven_xz",
   ShowText = "Menu",
   Theme = "DarkBlue",
   ToggleUIKeybind = "K",
   ConfigurationSaving = { Enabled = true, FolderName = "ModConfigs", FileName = "ApocalypseRising2_Final" },
})
local Players, RunService, UserInputService, Workspace, Lighting, GuiService = game:GetService("Players"), game:GetService("RunService"), game:GetService("UserInputService"), game:GetService("Workspace"), game:GetService("Lighting"), game:GetService("GuiService")
local LocalPlayer = Players.LocalPlayer; local PlayerGui = LocalPlayer:WaitForChild("PlayerGui"); local Camera = Workspace.CurrentCamera
local Drawing_Container = Instance.new("ScreenGui"); Drawing_Container.Name = "Drawing_Container_Global"; Drawing_Container.DisplayOrder = 999; Drawing_Container.ResetOnSpawn = false; Drawing_Container.Parent = PlayerGui

-- =================================================================================
-- VARI√ÅVEIS DE CONFIGURA√á√ÉO
-- =================================================================================
-- Aimbot
local AimAssistEnabled = true; local FieldOfView = 150; local TargetPartName = "Head"; local TeamCheckEnabled = true; local FOV_Circle_Enabled = true
local FOV_Circle_Color = Color3.fromRGB(255, 255, 255); local Aimbot_MaxDistance = 300; local currentAimbotTarget = nil
local PredictionAmount = 0.12; local Smoothness = 1.0
-- Hitbox Extender
local Hitbox_Enabled = false; local Hitbox_SizeMultiplier = 1.5; local isCurrentlyAimingForHitbox = false;
-- ESP de Jogadores
local ESP_Enabled = true; local Box_Enabled = true; local Skeleton_Enabled = true; local Name_Enabled = true; local InfoBar_Enabled = true; local Tracer_Enabled = false
local ESP_MaxDistance = 5000; local ESP_TextScale = 1
local ESP_Color = Color3.fromRGB(0, 255, 255); local Skeleton_Color = Color3.fromRGB(255, 170, 0); local Text_Color = Color3.fromRGB(255, 255, 255)
-- ESP de Ve√≠culos
local VehicleESP_Enabled = true; local VehicleESP_Color = Color3.fromRGB(0, 255, 0); local VehicleESP_MaxDistance = 2000
-- Misc
local Fullbright_Enabled = false
local originalAmbient, originalOutdoorAmbient, originalBrightness, originalFogEnd = nil, nil, nil, nil
local originalHeadSizes = {}

-- =================================================================================
-- CRIA√á√ÉO DOS ELEMENTOS DO MENU
-- =================================================================================
local AimbotTab = Window:CreateTab("Aimbot", "crosshair")
AimbotTab:CreateLabel("üéØ Aimbot ativado com: Bot√£o Direito do Rato")
AimbotTab:CreateToggle({Name = "‚úÖ Ativar Aimbot", CurrentValue = AimAssistEnabled, Flag = "AimbotEnabledFlag_Final", Callback = function(Value) AimAssistEnabled = Value end,})
AimbotTab:CreateSlider({ Name = "‚≠ï Campo de Vis√£o (FOV)", Range = {10, 500}, Increment = 10, Suffix = "px", CurrentValue = FieldOfView, Flag = "AimbotFOVFlag_Final", Callback = function(Value) FieldOfView = Value end,})
AimbotTab:CreateSlider({ Name = "üìè Dist√¢ncia M√°xima", Range = {10, 1000}, Increment = 10, Suffix = "m", CurrentValue = Aimbot_MaxDistance, Flag = "AimbotMaxDistance_Final", Callback = function(Value) Aimbot_MaxDistance = Value end,})
AimbotTab:CreateSlider({ Name = "üí® Suavidade da Mira", Range = {0.1, 1}, Increment = 0.1, Suffix = "", CurrentValue = Smoothness, Flag = "AimbotSmoothnessFlag_Final", Callback = function(Value) Smoothness = Value end,})
-- !ATUALIZADO! -> Slider de Previs√£o Simplificado
AimbotTab:CreateSlider({ Name = "üéØ Previs√£o de Alvo", Range = {0, 0.5}, Increment = 0.01, Suffix = "s", CurrentValue = PredictionAmount, Flag = "AimbotPrediction_Final", Callback = function(Value) PredictionAmount = Value end,})
AimbotTab:CreateDropdown({ Name = "üíÄ Parte do Corpo Alvo", Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, CurrentOption = {"Head"}, MultipleOptions = false, Flag = "AimbotTargetPartFlag_Final", Callback = function(Options) TargetPartName = Options[1] end,})
AimbotTab:CreateToggle({ Name = "üõ°Ô∏è Verificar Time (Inimigos)", CurrentValue = TeamCheckEnabled, Flag = "AimbotTeamCheck_Final", Callback = function(Value) TeamCheckEnabled = Value end,})
AimbotTab:CreateToggle({ Name = "üëÅÔ∏è Desenhar C√≠rculo de FOV", CurrentValue = FOV_Circle_Enabled, Flag = "AimbotDrawFOV_Final", Callback = function(Value) FOV_Circle_Enabled = Value end,})
AimbotTab:CreateColorPicker({ Name = "üé® Cor do C√≠rculo de FOV", Color = FOV_Circle_Color, Flag = "FOVCircleColor_Final", Callback = function(Value) FOV_Circle_Color = Value end })
AimbotTab:CreateDivider()
AimbotTab:CreateParagraph({Title = "üí• Hitbox Extender", Content = "Aumenta a cabe√ßa dos inimigos enquanto mira. AVISO: Usar valores altos no slider pode causar instabilidade!"})
AimbotTab:CreateToggle({Name = "‚úÖ Ativar Hitbox Extender", CurrentValue = Hitbox_Enabled, Flag = "HitboxEnabled_Final", Callback = function(Value) Hitbox_Enabled = Value; if not Value then for player, data in pairs(originalHeadSizes) do if data.head and data.head.Parent then data.head.Size = data.originalSize end end; originalHeadSizes = {} end end,})
AimbotTab:CreateSlider({ Name = "üìè Tamanho da Extens√£o", Range = {1.0, 8.0}, Increment = 0.1, Suffix = "x", CurrentValue = Hitbox_SizeMultiplier, Flag = "HitboxSize_Final", Callback = function(Value) Hitbox_SizeMultiplier = Value end,})

local ESPTab = Window:CreateTab("ESP", "eye")
ESPTab:CreateParagraph({Title = "üë§ ESP de Jogadores", Content = "Visualiza√ß√£o de informa√ß√µes sobre outros jogadores."})
ESPTab:CreateToggle({ Name = "‚úÖ Ativar ESP de Jogadores", CurrentValue = ESP_Enabled, Flag = "ESPEnabledFlag_Final", Callback = function(Value) ESP_Enabled = Value; end,})
ESPTab:CreateSlider({ Name = "üìè Dist√¢ncia M√°xima", Range = {50, 5000}, Increment = 10, Suffix = "m", CurrentValue = ESP_MaxDistance, Flag = "ESPMaxDistance_Final", Callback = function(Value) ESP_MaxDistance = Value end,})
ESPTab:CreateSlider({ Name = "üìù Tamanho do Texto", Range = {0.1, 1}, Increment = 0.1, Suffix = "x", CurrentValue = ESP_TextScale, Flag = "ESPTextScale_Final", Callback = function(Value) ESP_TextScale = Value end,})
ESPTab:CreateToggle({ Name = "üì¶ Mostrar Caixas (Box)", CurrentValue = Box_Enabled, Flag = "ESPBoxFlag_Final", Callback = function(Value) Box_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "üíÄ Mostrar Esqueleto", CurrentValue = Skeleton_Enabled, Flag = "ESPSkeletonFlag_Final", Callback = function(Value) Skeleton_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "üè∑Ô∏è Mostrar Nomes", CurrentValue = Name_Enabled, Flag = "ESPNameFlag_Final", Callback = function(Value) Name_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "üìä Mostrar Barra de Informa√ß√£o", CurrentValue = InfoBar_Enabled, Flag = "ESPInfoBarFlag_Final", Callback = function(Value) InfoBar_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "üìç Mostrar Linha de Mira (Tracer)", CurrentValue = Tracer_Enabled, Flag = "ESPTracerFlag_Final", Callback = function(Value) Tracer_Enabled = Value end, })
ESPTab:CreateColorPicker({ Name = "üé® Cor da Caixa e Tracer", Color = ESP_Color, Flag = "ESPColorFlag_Final", Callback = function(Value) ESP_Color = Value end })
ESPTab:CreateColorPicker({ Name = "üé® Cor do Esqueleto", Color = Skeleton_Color, Flag = "ESPSkeletonColorFlag_Final", Callback = function(Value) Skeleton_Color = Value end })
ESPTab:CreateColorPicker({ Name = "üé® Cor do Texto", Color = Text_Color, Flag = "ESPTextColorFlag_Final", Callback = function(Value) Text_Color = Value end })
ESPTab:CreateDivider()
ESPTab:CreateParagraph({Title = "üöó ESP de Ve√≠culos", Content = "Visualiza√ß√£o de informa√ß√µes sobre ve√≠culos."})
ESPTab:CreateToggle({ Name = "‚úÖ Ativar ESP de Ve√≠culos", CurrentValue = VehicleESP_Enabled, Flag = "VehicleESPEnabled_Final", Callback = function(Value) VehicleESP_Enabled = Value end,})
ESPTab:CreateSlider({ Name = "üìè Dist√¢ncia M√°xima", Range = {100, 10000}, Increment = 100, Suffix = "m", CurrentValue = VehicleESP_MaxDistance, Flag = "VehicleESPMaxDistance_Final", Callback = function(Value) VehicleESP_MaxDistance = Value end,})
ESPTab:CreateColorPicker({ Name = "üé® Cor do ESP de Ve√≠culos", Color = VehicleESP_Color, Flag = "VehicleESPColor_Final", Callback = function(Value) VehicleESP_Color = Value end,})

local MiscTab = Window:CreateTab("Misc", "settings")
MiscTab:CreateToggle({ Name = "‚òÄÔ∏è Fullbright (Sempre Dia)", CurrentValue = Fullbright_Enabled, Flag = "FullbrightEnabled_Final", Callback = function(Value) Fullbright_Enabled = Value; if Fullbright_Enabled then if originalAmbient == nil then originalAmbient = Lighting.Ambient; originalOutdoorAmbient = Lighting.OutdoorAmbient; originalBrightness = Lighting.Brightness; originalFogEnd = Lighting.FogEnd end else if originalAmbient ~= nil then Lighting.Ambient = originalAmbient; Lighting.OutdoorAmbient = originalOutdoorAmbient; Lighting.Brightness = originalBrightness; Lighting.FogEnd = originalFogEnd end end end,})
MiscTab:CreateDivider()
MiscTab:CreateButton({ Name = "üö® Panic (Encerrar Script)", Callback = function() AimAssistEnabled, ESP_Enabled, VehicleESP_Enabled, Fullbright_Enabled, Hitbox_Enabled = false, false, false, false, false; if originalAmbient ~= nil then Lighting.Ambient = originalAmbient; Lighting.OutdoorAmbient = originalOutdoorAmbient; Lighting.Brightness = originalBrightness; Lighting.FogEnd = originalFogEnd end; for player, data in pairs(originalHeadSizes) do if data.head and data.head.Parent then data.head.Size = data.originalSize end end; originalHeadSizes = {}; RunService.RenderStepped:Wait(); if AimbotConnection then AimbotConnection:Disconnect() end; if ESPConnection then ESPConnection:Disconnect() end; if VehicleESPConnection then VehicleESPConnection:Disconnect() end; if FullbrightConnection then FullbrightConnection:Disconnect() end; if FOV_Circle then FOV_Circle.Visible = false; FOV_Circle = nil end; if Drawing_Container then Drawing_Container:Destroy() end; Rayfield:Destroy() end,})

local CreditsTab = Window:CreateTab("Cr√©ditos", "star")
CreditsTab:CreateParagraph({Title = "üíª Desenvolvedor", Content = "@keven_xz"})
CreditsTab:CreateParagraph({Title = "üìÖ Data de Cria√ß√£o", Content = "01/08/2025"})
CreditsTab:CreateParagraph({Title = "üîÑ √öltima Atualiza√ß√£o", Content = "01/08/2025"})
CreditsTab:CreateDivider()
CreditsTab:CreateLabel("Status: ‚úÖ Totalmente Seguro", "shield-check", Color3.fromRGB(0, 255, 0), false)

-- =================================================================================
-- L√ìGICA DO SCRIPT
-- =================================================================================
local FOV_Circle = Drawing.new("Circle"); FOV_Circle.Visible = false; FOV_Circle.Thickness = 1; FOV_Circle.NumSides = 64; FOV_Circle.Filled = false
local linePool = {}; local function GetLine() if #linePool > 0 then local line = table.remove(linePool); line.Visible = true; return line; end; local line = Instance.new("Frame"); line.AnchorPoint = Vector2.new(0.5, 0.5); line.BorderSizePixel = 0; line.Parent = Drawing_Container; return line; end
local function ReturnLine(line) line.Visible = false; table.insert(linePool, line); end; local usedLines = {}
local function DrawLine(startVec, endVec, color, thickness) local distance = (startVec - endVec).Magnitude; local center = (startVec + endVec) / 2; local angle = math.atan2(endVec.Y - startVec.Y, endVec.X - startVec.X); local line = GetLine(); line.Size = UDim2.new(0, distance, 0, thickness); line.Position = UDim2.fromOffset(center.X, center.Y); line.Rotation = math.deg(angle); line.BackgroundColor3 = color; table.insert(usedLines, line); end
local skeletonBones = {{"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"}, {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"}, {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightUpperArm", "RightHand"}, {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"}, {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightUpperLeg", "RightFoot"}}
local ORIGINAL_NAME_SIZE = 14; local ORIGINAL_INFO_SIZE = 12
local playerLabels = {}; local function GetPlayerLabel(player) if playerLabels[player] then return playerLabels[player].name, playerLabels[player].info end; local nameLabel = Instance.new("TextLabel"); nameLabel.Font = Enum.Font.SourceSansBold; nameLabel.TextColor3 = Text_Color; nameLabel.BackgroundTransparency = 1; nameLabel.TextStrokeTransparency = 0; nameLabel.AnchorPoint = Vector2.new(0.5, 1); nameLabel.Parent = Drawing_Container; local infoLabel = Instance.new("TextLabel"); infoLabel.Font = Enum.Font.SourceSansSemibold; infoLabel.TextColor3 = Text_Color; infoLabel.BackgroundTransparency = 1; infoLabel.TextStrokeTransparency = 0; infoLabel.AnchorPoint = Vector2.new(0.5, 0); infoLabel.Parent = Drawing_Container; playerLabels[player] = {name = nameLabel, info = infoLabel}; return nameLabel, infoLabel; end
local vehicleLabels = {}; local function GetVehicleLabel(vehicle) if vehicleLabels[vehicle] then return vehicleLabels[vehicle] end; local newLabel = Instance.new("TextLabel"); newLabel.TextSize = 14; newLabel.Font = Enum.Font.SourceSansBold; newLabel.BackgroundTransparency = 1; newLabel.TextStrokeTransparency = 0; newLabel.AnchorPoint = Vector2.new(0.5, 0); newLabel.Parent = Drawing_Container; vehicleLabels[vehicle] = newLabel; return newLabel; end

local AimbotConnection, ESPConnection, VehicleESPConnection, FullbrightConnection
local function findNewTarget() local closest = nil; local shortestDist = FieldOfView; for _, player in ipairs(Players:GetPlayers()) do if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild(TargetPartName) and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then local targetPart = player.Character[TargetPartName]; local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude; if distance <= Aimbot_MaxDistance then if not TeamCheckEnabled or not player.Team or player.Team ~= LocalPlayer.Team then local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPart.Position); if onScreen then local mousePosition = UserInputService:GetMouseLocation(); local fovDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePosition).Magnitude; if fovDistance < shortestDist then shortestDist = fovDistance; closest = targetPart end end end end end end; return closest end

AimbotConnection = RunService.RenderStepped:Connect(function()
    pcall(function()
        if AimAssistEnabled and FOV_Circle_Enabled then
            FOV_Circle.Visible = true; FOV_Circle.Color = FOV_Circle_Color; FOV_Circle.Radius = FieldOfView; FOV_Circle.Position = UserInputService:GetMouseLocation()
        else
            FOV_Circle.Visible = false
        end
        local isAiming = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
        if AimAssistEnabled and isAiming then
            local targetIsValid = false
            if currentAimbotTarget and currentAimbotTarget.Parent and currentAimbotTarget.Parent:FindFirstChild("Humanoid") and currentAimbotTarget.Parent.Humanoid.Health > 0 then
                local screenPoint, onScreen = Camera:WorldToViewportPoint(currentAimbotTarget.Position)
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - currentAimbotTarget.Position).Magnitude
                if onScreen and (Vector2.new(screenPoint.X, screenPoint.Y) - UserInputService:GetMouseLocation()).Magnitude < FieldOfView and distance <= Aimbot_MaxDistance then targetIsValid = true end
            end
            if not targetIsValid then currentAimbotTarget = findNewTarget() end
            if currentAimbotTarget then
                local aimAtPosition = currentAimbotTarget.Position + (currentAimbotTarget.Velocity * PredictionAmount)
                local screenPoint, onScreen = Camera:WorldToViewportPoint(aimAtPosition)
                if onScreen then
                    local mouseDelta = Vector2.new(screenPoint.X, screenPoint.Y) - UserInputService:GetMouseLocation()
                    mousemoverel(mouseDelta.X * Smoothness, mouseDelta.Y * Smoothness)
                end
            end
        else
            currentAimbotTarget = nil
        end
        if Hitbox_Enabled then if isAiming and not isCurrentlyAimingForHitbox then isCurrentlyAimingForHitbox = true; for _, player in ipairs(Players:GetPlayers()) do if player ~= LocalPlayer and player.Character then local head = player.Character:FindFirstChild("Head"); if head and not originalHeadSizes[player] then originalHeadSizes[player] = {head = head, originalSize = head.Size}; head.Size = head.Size * Hitbox_SizeMultiplier end end end elseif not isAiming and isCurrentlyAimingForHitbox then isCurrentlyAimingForHitbox = false; for player, data in pairs(originalHeadSizes) do if data.head and data.head.Parent then data.head.Size = data.originalSize end end; originalHeadSizes = {} end end
    end)
end)

ESPConnection = RunService.RenderStepped:Connect(function() if not ESP_Enabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then Drawing_Container.Enabled = false; return end; Drawing_Container.Enabled = true; for _, line in ipairs(usedLines) do ReturnLine(line) end; usedLines = {}; for _, labelGroup in pairs(playerLabels) do labelGroup.name.Visible = false; labelGroup.info.Visible = false; end; local guiInset = GuiService:GetGuiInset(); local localPos = LocalPlayer.Character.HumanoidRootPart.Position; for _, player in ipairs(Players:GetPlayers()) do pcall(function() if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then local distance = math.floor((localPos - player.Character.HumanoidRootPart.Position).Magnitude); if distance <= ESP_MaxDistance then local char = player.Character; local cframe, size = char:GetBoundingBox(); local corners = {cframe * Vector3.new(size.X/2, size.Y/2, size.Z/2), cframe * Vector3.new(size.X/2, size.Y/2, -size.Z/2), cframe * Vector3.new(size.X/2, -size.Y/2, size.Z/2), cframe * Vector3.new(size.X/2, -size.Y/2, -size.Z/2), cframe * Vector3.new(-size.X/2, size.Y/2, size.Z/2), cframe * Vector3.new(-size.X/2, size.Y/2, -size.Z/2), cframe * Vector3.new(-size.X/2, -size.Y/2, size.Z/2), cframe * Vector3.new(-size.X/2, -size.Y/2, -size.Z/2)}; local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge; local onScreen = false; for _, corner in ipairs(corners) do local pos, visible = Camera:WorldToViewportPoint(corner) if visible then onScreen = true; minX = math.min(minX, pos.X); minY = math.min(minY, pos.Y); maxX = math.max(maxX, pos.X); maxY = math.max(maxY, pos.Y) end end; if onScreen then local boxTopLeft = Vector2.new(minX, minY - guiInset.Y); local boxBottomRight = Vector2.new(maxX, maxY - guiInset.Y); local boxSize = boxBottomRight - boxTopLeft; if Box_Enabled then DrawLine(boxTopLeft, Vector2.new(boxBottomRight.X, boxTopLeft.Y), ESP_Color, 1.5); DrawLine(boxTopLeft, Vector2.new(boxTopLeft.X, boxBottomRight.Y), ESP_Color, 1.5); DrawLine(boxBottomRight, Vector2.new(boxTopLeft.X, boxBottomRight.Y), ESP_Color, 1.5); DrawLine(boxBottomRight, Vector2.new(boxBottomRight.X, boxTopLeft.Y), ESP_Color, 1.5) end; if Skeleton_Enabled then for _, bone in ipairs(skeletonBones) do local p1 = char:FindFirstChild(bone[1]); local p2 = char:FindFirstChild(bone[2]) if p1 and p2 then local pos1, vis1 = Camera:WorldToViewportPoint(p1.Position); local pos2, vis2 = Camera:WorldToViewportPoint(p2.Position) if vis1 and vis2 then local adjustedPos1 = Vector2.new(pos1.X, pos1.Y - guiInset.Y); local adjustedPos2 = Vector2.new(pos2.X, pos2.Y - guiInset.Y); DrawLine(adjustedPos1, adjustedPos2, Skeleton_Color, 1) end end end end; local nameLabel, infoLabel = GetPlayerLabel(player); nameLabel.TextColor3 = Text_Color; infoLabel.TextColor3 = Text_Color; nameLabel.TextSize = ORIGINAL_NAME_SIZE * ESP_TextScale; infoLabel.TextSize = ORIGINAL_INFO_SIZE * ESP_TextScale; if Name_Enabled then nameLabel.Text = player.Name; nameLabel.Position = UDim2.fromOffset(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y - 2); nameLabel.Visible = true end; if InfoBar_Enabled then local health = math.floor((char.Humanoid.Health / char.Humanoid.MaxHealth) * 100); infoLabel.Text = string.format("[ %dm ] [ %d%% ]", distance, health); infoLabel.Position = UDim2.fromOffset(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y + boxSize.Y + 2); infoLabel.Visible = true end; if Tracer_Enabled then local tracerStart = Vector2.new(Camera.ViewportSize.X / 2, 0); local tracerEnd = Vector2.new(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y); DrawLine(tracerStart, tracerEnd, ESP_Color, 1) end; end; end; end; end) end
end)

VehicleESPConnection = RunService.RenderStepped:Connect(function() if not VehicleESP_Enabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end; local vehiclesFolder = Workspace:FindFirstChild("Vehicles"); if not vehiclesFolder then return end; local localPos = LocalPlayer.Character.HumanoidRootPart.Position; for _, label in pairs(vehicleLabels) do label.Visible = false end; for _, vehicle in ipairs(vehiclesFolder:GetChildren()) do pcall(function() if vehicle:IsA("Model") and vehicle.PrimaryPart then local distance = math.floor((localPos - vehicle.PrimaryPart.Position).Magnitude); if distance <= VehicleESP_MaxDistance then local screenPoint, onScreen = Camera:WorldToViewportPoint(vehicle.PrimaryPart.Position); if onScreen then local label = GetVehicleLabel(vehicle); label.Visible = true; label.TextColor3 = VehicleESP_Color; label.Text = vehicle.Name .. "\n[" .. distance .. "m]"; label.Position = UDim2.fromOffset(screenPoint.X, screenPoint.Y) end end end end) end end)
FullbrightConnection = RunService.RenderStepped:Connect(function() if Fullbright_Enabled then pcall(function() Lighting.Ambient = Color3.fromRGB(200, 200, 200); Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200); Lighting.Brightness = 0.5; Lighting.FogEnd = 100000 end) end end)

-- =================================================================================
-- CARREGAMENTO DAS CONFIGURA√á√ïES
-- =================================================================================
Rayfield:LoadConfiguration()
print("Script Final por @keven_xz (v2.1 - Precis√£o) carregado com sucesso!")
