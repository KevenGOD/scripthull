--[[
    Menu ðŸ’€ Apocalypse Rising 2 ðŸ’€ - EdiÃ§Ã£o Final v1.8 (PersistÃªncia de Alvo)

    CRÃ‰DITOS:
    - Criador: @keven_xz

    ALTERAÃ‡Ã•ES NESTA VERSÃƒO:
    - PERSISTÃŠNCIA DE ALVO (STICKY AIM): O Aimbot agora mantÃ©m a mira no alvo adquirido,
      impedindo que salte para outros inimigos. SÃ³ procura um novo alvo se o atual for perdido.
]]

-- =================================================================================
-- CARREGAMENTO DA BIBLIOTECA RAYFIELD E CONFIGURAÃ‡ÃƒO DA UI
-- =================================================================================
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "Menu ðŸ’€ Apocalypse Rising 2 ðŸ’€",
   LoadingTitle = "A carregar Script...",
   LoadingSubtitle = "por @keven_xz",
   ShowText = "Menu",
   Theme = "DarkBlue",
   ToggleUIKeybind = "K",
   ConfigurationSaving = { Enabled = true, FolderName = "ModConfigs", FileName = "ApocalypseRising2_Final" },
})
local Players, RunService, UserInputService, Workspace, Lighting, GuiService = game:GetService("Players"), game:GetService("RunService"), game:GetService("UserInputService"), game:GetService("Workspace"), game:GetService("Lighting"), game:GetService("GuiService")
local LocalPlayer = Players.LocalPlayer; local PlayerGui = LocalPlayer:WaitForChild("PlayerGui"); local Camera = Workspace.CurrentCamera
local Drawing_Container = Instance.new("ScreenGui"); Drawing_Container.Name = "Drawing_Container_Global"; Drawing_Container.DisplayOrder = 999; Drawing_Container.ResetOnSpawn = false; Drawing_Container.Parent = PlayerGui

-- =================================================================================
-- VARIÃVEIS DE CONFIGURAÃ‡ÃƒO
-- =================================================================================
-- Aimbot
local AimAssistEnabled = true; local FieldOfView = 35; local TargetPartName = "Head"; local TeamCheckEnabled = true; local FOV_Circle_Enabled = true
local FOV_Circle_Color = Color3.fromRGB(255, 255, 255); local Aimbot_MaxDistance = 100; local currentAimbotTarget = nil -- !NOVO!
-- Hitbox Extender
local Hitbox_Enabled = false; local Hitbox_SizeMultiplier = 1.5; local isCurrentlyAimingForHitbox = false;
-- ESP de Jogadores
local ESP_Enabled = true; local Box_Enabled = true; local Skeleton_Enabled = true; local Name_Enabled = true; local InfoBar_Enabled = true; local Tracer_Enabled = false
local ESP_MaxDistance = 5000; local ESP_TextScale = 1
local ESP_Color = Color3.fromRGB(0, 255, 255); local Skeleton_Color = Color3.fromRGB(255, 170, 0); local Text_Color = Color3.fromRGB(255, 255, 255)
-- ESP de VeÃ­culos
local VehicleESP_Enabled = true; local VehicleESP_Color = Color3.fromRGB(0, 255, 0); local VehicleESP_MaxDistance = 2000
-- Misc
local Fullbright_Enabled = false
local originalAmbient, originalOutdoorAmbient, originalBrightness, originalFogEnd = nil, nil, nil, nil
local originalHeadSizes = {}

-- =================================================================================
-- CRIAÃ‡ÃƒO DOS ELEMENTOS DO MENU
-- =================================================================================
local AimbotTab = Window:CreateTab("Aimbot", "crosshair")
AimbotTab:CreateLabel("ðŸŽ¯ Aimbot ativado com: BotÃ£o Direito do Rato")
AimbotTab:CreateToggle({Name = "âœ… Ativar Aimbot", CurrentValue = AimAssistEnabled, Flag = "AimbotEnabledFlag_Final", Callback = function(Value) AimAssistEnabled = Value end,})
AimbotTab:CreateSlider({ Name = "â­• Campo de VisÃ£o (FOV)", Range = {10, 180}, Increment = 5, Suffix = "Â°", CurrentValue = FieldOfView, Flag = "AimbotFOVFlag_Final", Callback = function(Value) FieldOfView = Value end,})
AimbotTab:CreateSlider({ Name = "ðŸ“ DistÃ¢ncia MÃ¡xima do Aimbot", Range = {10, 1000}, Increment = 10, Suffix = "m", CurrentValue = Aimbot_MaxDistance, Flag = "AimbotMaxDistance_Final", Callback = function(Value) Aimbot_MaxDistance = Value end,})
AimbotTab:CreateDropdown({ Name = "ðŸ’€ Parte do Corpo Alvo", Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, CurrentOption = {"Head"}, MultipleOptions = false, Flag = "AimbotTargetPartFlag_Final", Callback = function(Options) TargetPartName = Options[1] end,})
AimbotTab:CreateToggle({ Name = "ðŸ›¡ï¸ Verificar Time (Inimigos)", CurrentValue = TeamCheckEnabled, Flag = "AimbotTeamCheck_Final", Callback = function(Value) TeamCheckEnabled = Value end,})
AimbotTab:CreateToggle({ Name = "ðŸ‘ï¸ Desenhar CÃ­rculo de FOV", CurrentValue = FOV_Circle_Enabled, Flag = "AimbotDrawFOV_Final", Callback = function(Value) FOV_Circle_Enabled = Value end,})
AimbotTab:CreateColorPicker({ Name = "ðŸŽ¨ Cor do CÃ­rculo de FOV", Color = FOV_Circle_Color, Flag = "FOVCircleColor_Final", Callback = function(Value) FOV_Circle_Color = Value end })
AimbotTab:CreateDivider()
AimbotTab:CreateParagraph({Title = "ðŸ’¥ Hitbox Extender", Content = "Aumenta a cabeÃ§a dos inimigos enquanto mira. AVISO: Usar valores altos no slider pode causar instabilidade e congelar o jogo!"})
AimbotTab:CreateToggle({Name = "âœ… Ativar Hitbox Extender", CurrentValue = Hitbox_Enabled, Flag = "HitboxEnabled_Final", Callback = function(Value) Hitbox_Enabled = Value; if not Value then for player, data in pairs(originalHeadSizes) do if data.head and data.head.Parent then data.head.Size = data.originalSize end end; originalHeadSizes = {} end end,})
AimbotTab:CreateSlider({ Name = "ðŸ“ Tamanho da ExtensÃ£o", Range = {1.0, 8.0}, Increment = 0.1, Suffix = "x", CurrentValue = Hitbox_SizeMultiplier, Flag = "HitboxSize_Final", Callback = function(Value) Hitbox_SizeMultiplier = Value end,})

local ESPTab = Window:CreateTab("ESP", "eye")
ESPTab:CreateParagraph({Title = "ðŸ‘¤ ESP de Jogadores", Content = "VisualizaÃ§Ã£o de informaÃ§Ãµes sobre outros jogadores."})
ESPTab:CreateToggle({ Name = "âœ… Ativar ESP de Jogadores", CurrentValue = ESP_Enabled, Flag = "ESPEnabledFlag_Final", Callback = function(Value) ESP_Enabled = Value; end,})
ESPTab:CreateSlider({ Name = "ðŸ“ DistÃ¢ncia MÃ¡xima", Range = {50, 5000}, Increment = 10, Suffix = "m", CurrentValue = ESP_MaxDistance, Flag = "ESPMaxDistance_Final", Callback = function(Value) ESP_MaxDistance = Value end,})
ESPTab:CreateSlider({ Name = "ðŸ“ Tamanho do Texto", Range = {0.1, 1}, Increment = 0.1, Suffix = "x", CurrentValue = ESP_TextScale, Flag = "ESPTextScale_Final", Callback = function(Value) ESP_TextScale = Value end,})
ESPTab:CreateToggle({ Name = "ðŸ“¦ Mostrar Caixas (Box)", CurrentValue = Box_Enabled, Flag = "ESPBoxFlag_Final", Callback = function(Value) Box_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "ðŸ’€ Mostrar Esqueleto", CurrentValue = Skeleton_Enabled, Flag = "ESPSkeletonFlag_Final", Callback = function(Value) Skeleton_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "ðŸ·ï¸ Mostrar Nomes", CurrentValue = Name_Enabled, Flag = "ESPNameFlag_Final", Callback = function(Value) Name_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "ðŸ“Š Mostrar Barra de InformaÃ§Ã£o", CurrentValue = InfoBar_Enabled, Flag = "ESPInfoBarFlag_Final", Callback = function(Value) InfoBar_Enabled = Value end, })
ESPTab:CreateToggle({ Name = "ðŸ“ Mostrar Linha de Mira (Tracer)", CurrentValue = Tracer_Enabled, Flag = "ESPTracerFlag_Final", Callback = function(Value) Tracer_Enabled = Value end, })
ESPTab:CreateColorPicker({ Name = "ðŸŽ¨ Cor da Caixa e Tracer", Color = ESP_Color, Flag = "ESPColorFlag_Final", Callback = function(Value) ESP_Color = Value end })
ESPTab:CreateColorPicker({ Name = "ðŸŽ¨ Cor do Esqueleto", Color = Skeleton_Color, Flag = "ESPSkeletonColorFlag_Final", Callback = function(Value) Skeleton_Color = Value end })
ESPTab:CreateColorPicker({ Name = "ðŸŽ¨ Cor do Texto", Color = Text_Color, Flag = "ESPTextColorFlag_Final", Callback = function(Value) Text_Color = Value end })
ESPTab:CreateDivider()
ESPTab:CreateParagraph({Title = "ðŸš— ESP de VeÃ­culos", Content = "VisualizaÃ§Ã£o de informaÃ§Ãµes sobre veÃ­culos."})
ESPTab:CreateToggle({ Name = "âœ… Ativar ESP de VeÃ­culos", CurrentValue = VehicleESP_Enabled, Flag = "VehicleESPEnabled_Final", Callback = function(Value) VehicleESP_Enabled = Value end,})
ESPTab:CreateSlider({ Name = "ðŸ“ DistÃ¢ncia MÃ¡xima", Range = {100, 10000}, Increment = 100, Suffix = "m", CurrentValue = VehicleESP_MaxDistance, Flag = "VehicleESPMaxDistance_Final", Callback = function(Value) VehicleESP_MaxDistance = Value end,})
ESPTab:CreateColorPicker({ Name = "ðŸŽ¨ Cor do ESP de VeÃ­culos", Color = VehicleESP_Color, Flag = "VehicleESPColor_Final", Callback = function(Value) VehicleESP_Color = Value end,})

local MiscTab = Window:CreateTab("Misc", "settings")
MiscTab:CreateToggle({ Name = "â˜€ï¸ Fullbright (Sempre Dia)", CurrentValue = Fullbright_Enabled, Flag = "FullbrightEnabled_Final", Callback = function(Value) Fullbright_Enabled = Value; if Fullbright_Enabled then if originalAmbient == nil then originalAmbient = Lighting.Ambient; originalOutdoorAmbient = Lighting.OutdoorAmbient; originalBrightness = Lighting.Brightness; originalFogEnd = Lighting.FogEnd end else if originalAmbient ~= nil then Lighting.Ambient = originalAmbient; Lighting.OutdoorAmbient = originalOutdoorAmbient; Lighting.Brightness = originalBrightness; Lighting.FogEnd = originalFogEnd end end end,})
MiscTab:CreateDivider()
MiscTab:CreateButton({ Name = "ðŸš¨ Panic (Encerrar Script)", Callback = function() AimAssistEnabled, ESP_Enabled, VehicleESP_Enabled, Fullbright_Enabled, Hitbox_Enabled = false, false, false, false, false; if originalAmbient ~= nil then Lighting.Ambient = originalAmbient; Lighting.OutdoorAmbient = originalOutdoorAmbient; Lighting.Brightness = originalBrightness; Lighting.FogEnd = originalFogEnd end; for player, data in pairs(originalHeadSizes) do if data.head and data.head.Parent then data.head.Size = data.originalSize end end; originalHeadSizes = {}; RunService.RenderStepped:Wait(); if AimbotConnection then AimbotConnection:Disconnect() end; if ESPConnection then ESPConnection:Disconnect() end; if VehicleESPConnection then VehicleESPConnection:Disconnect() end; if FullbrightConnection then FullbrightConnection:Disconnect() end; if InputBeganConnection then InputBeganConnection:Disconnect() end; if InputEndedConnection then InputEndedConnection:Disconnect() end; if FOV_Circle then FOV_Circle.Visible = false; FOV_Circle = nil end; if Drawing_Container then Drawing_Container:Destroy() end; Rayfield:Destroy() end,})

local CreditsTab = Window:CreateTab("CrÃ©ditos", "star")
CreditsTab:CreateParagraph({Title = "ðŸ’» Desenvolvedor", Content = "@keven_xz"})
CreditsTab:CreateParagraph({Title = "ðŸ“… Data de CriaÃ§Ã£o", Content = "11/07/2025"})
CreditsTab:CreateParagraph({Title = "ðŸ”„ Ãšltima AtualizaÃ§Ã£o", Content = "01/08/2025"})
CreditsTab:CreateDivider()
CreditsTab:CreateLabel("Status: âœ… Totalmente Seguro", "shield-check", Color3.fromRGB(0, 255, 0), false)

-- =================================================================================
-- LÃ“GICA DO SCRIPT
-- =================================================================================
-- FunÃ§Ãµes Auxiliares
local FOV_Circle = Drawing.new("Circle"); FOV_Circle.Visible = false; FOV_Circle.Thickness = 1; FOV_Circle.NumSides = 64; FOV_Circle.Filled = false
local linePool = {}; local function GetLine() if #linePool > 0 then local line = table.remove(linePool); line.Visible = true; return line; end; local line = Instance.new("Frame"); line.AnchorPoint = Vector2.new(0.5, 0.5); line.BorderSizePixel = 0; line.Parent = Drawing_Container; return line; end
local function ReturnLine(line) line.Visible = false; table.insert(linePool, line); end; local usedLines = {}
local function DrawLine(startVec, endVec, color, thickness) local distance = (startVec - endVec).Magnitude; local center = (startVec + endVec) / 2; local angle = math.atan2(endVec.Y - startVec.Y, endVec.X - startVec.X); local line = GetLine(); line.Size = UDim2.new(0, distance, 0, thickness); line.Position = UDim2.fromOffset(center.X, center.Y); line.Rotation = math.deg(angle); line.BackgroundColor3 = color; table.insert(usedLines, line); end
local skeletonBones = {{"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"}, {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"}, {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightUpperArm", "RightHand"}, {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"}, {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightUpperLeg", "RightFoot"}}
local ORIGINAL_NAME_SIZE = 14; local ORIGINAL_INFO_SIZE = 12
local playerLabels = {}; local function GetPlayerLabel(player) if playerLabels[player] then return playerLabels[player].name, playerLabels[player].info end; local nameLabel = Instance.new("TextLabel"); nameLabel.Font = Enum.Font.SourceSansBold; nameLabel.TextColor3 = Text_Color; nameLabel.BackgroundTransparency = 1; nameLabel.TextStrokeTransparency = 0; nameLabel.AnchorPoint = Vector2.new(0.5, 1); nameLabel.Parent = Drawing_Container; local infoLabel = Instance.new("TextLabel"); infoLabel.Font = Enum.Font.SourceSansSemibold; infoLabel.TextColor3 = Text_Color; infoLabel.BackgroundTransparency = 1; infoLabel.TextStrokeTransparency = 0; infoLabel.AnchorPoint = Vector2.new(0.5, 0); infoLabel.Parent = Drawing_Container; playerLabels[player] = {name = nameLabel, info = infoLabel}; return nameLabel, infoLabel; end
local vehicleLabels = {}; local function GetVehicleLabel(vehicle) if vehicleLabels[vehicle] then return vehicleLabels[vehicle] end; local newLabel = Instance.new("TextLabel"); newLabel.TextSize = 14; newLabel.Font = Enum.Font.SourceSansBold; newLabel.BackgroundTransparency = 1; newLabel.TextStrokeTransparency = 0; newLabel.AnchorPoint = Vector2.new(0.5, 0); newLabel.Parent = Drawing_Container; vehicleLabels[vehicle] = newLabel; return newLabel; end

-- Loops Principais (RenderStepped)
local AimbotConnection, ESPConnection, VehicleESPConnection, FullbrightConnection, HitboxConnection, InputBeganConnection, InputEndedConnection

-- LÃ³gica do Aimbot
local aiming = false
InputBeganConnection = UserInputService.InputBegan:Connect(function(input, processed) if input.UserInputType == Enum.UserInputType.MouseButton2 then aiming = true end end)
InputEndedConnection = UserInputService.InputEnded:Connect(function(input, processed) if input.UserInputType == Enum.UserInputType.MouseButton2 then aiming = false end end)

local function findNewTarget()
    local closest = nil; local shortestAngle = math.rad(FieldOfView)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(TargetPartName) then
            local targetPart = player.Character[TargetPartName]; local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local direction = (targetPart.Position - Camera.CFrame.Position).Unit
                local angle = math.acos(Camera.CFrame.LookVector:Dot(direction))
                local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                if angle < shortestAngle and distance <= Aimbot_MaxDistance and (not TeamCheckEnabled or not player.Team or player.Team ~= LocalPlayer.Team) then
                    shortestAngle = angle; closest = targetPart
                end
            end
        end
    end
    return closest
end

AimbotConnection = RunService.RenderStepped:Connect(function()
    pcall(function()
        if AimAssistEnabled and FOV_Circle_Enabled then
            FOV_Circle.Visible = true; FOV_Circle.Color = FOV_Circle_Color; FOV_Circle.Radius = FieldOfView * 2; FOV_Circle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        else
            FOV_Circle.Visible = false
        end
        if AimAssistEnabled and aiming then
            local targetIsValid = false
            if currentAimbotTarget and currentAimbotTarget.Parent and currentAimbotTarget.Parent:FindFirstChild("Humanoid") and currentAimbotTarget.Parent.Humanoid.Health > 0 then
                local direction = (currentAimbotTarget.Position - Camera.CFrame.Position).Unit
                local angle = math.acos(Camera.CFrame.LookVector:Dot(direction))
                local distance = (Camera.CFrame.Position - currentAimbotTarget.Position).Magnitude
                if angle < math.rad(FieldOfView) and distance <= Aimbot_MaxDistance then
                    targetIsValid = true
                end
            end
            if not targetIsValid then
                currentAimbotTarget = findNewTarget()
            end
            if currentAimbotTarget then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, currentAimbotTarget.Position)
            end
        else
            currentAimbotTarget = nil
        end
        -- ... Hitbox logic ...
    end)
end)

ESPConnection = RunService.RenderStepped:Connect(function() if not ESP_Enabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then Drawing_Container.Enabled = false; return end; Drawing_Container.Enabled = true; for _, line in ipairs(usedLines) do ReturnLine(line) end; usedLines = {}; for _, labelGroup in pairs(playerLabels) do labelGroup.name.Visible = false; labelGroup.info.Visible = false; end; local guiInset = GuiService:GetGuiInset(); local localPos = LocalPlayer.Character.HumanoidRootPart.Position; for _, player in ipairs(Players:GetPlayers()) do pcall(function() if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then local distance = math.floor((localPos - player.Character.HumanoidRootPart.Position).Magnitude); if distance <= ESP_MaxDistance then local char = player.Character; local cframe, size = char:GetBoundingBox(); local corners = {cframe * Vector3.new(size.X/2, size.Y/2, size.Z/2), cframe * Vector3.new(size.X/2, size.Y/2, -size.Z/2), cframe * Vector3.new(size.X/2, -size.Y/2, size.Z/2), cframe * Vector3.new(size.X/2, -size.Y/2, -size.Z/2), cframe * Vector3.new(-size.X/2, size.Y/2, size.Z/2), cframe * Vector3.new(-size.X/2, size.Y/2, -size.Z/2), cframe * Vector3.new(-size.X/2, -size.Y/2, size.Z/2), cframe * Vector3.new(-size.X/2, -size.Y/2, -size.Z/2)}; local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge; local onScreen = false; for _, corner in ipairs(corners) do local pos, visible = Camera:WorldToViewportPoint(corner) if visible then onScreen = true; minX = math.min(minX, pos.X); minY = math.min(minY, pos.Y); maxX = math.max(maxX, pos.X); maxY = math.max(maxY, pos.Y) end end; if onScreen then local boxTopLeft = Vector2.new(minX, minY - guiInset.Y); local boxBottomRight = Vector2.new(maxX, maxY - guiInset.Y); local boxSize = boxBottomRight - boxTopLeft; if Box_Enabled then DrawLine(boxTopLeft, Vector2.new(boxBottomRight.X, boxTopLeft.Y), ESP_Color, 1.5); DrawLine(boxTopLeft, Vector2.new(boxTopLeft.X, boxBottomRight.Y), ESP_Color, 1.5); DrawLine(boxBottomRight, Vector2.new(boxTopLeft.X, boxBottomRight.Y), ESP_Color, 1.5); DrawLine(boxBottomRight, Vector2.new(boxBottomRight.X, boxTopLeft.Y), ESP_Color, 1.5) end; if Skeleton_Enabled then for _, bone in ipairs(skeletonBones) do local p1 = char:FindFirstChild(bone[1]); local p2 = char:FindFirstChild(bone[2]) if p1 and p2 then local pos1, vis1 = Camera:WorldToViewportPoint(p1.Position); local pos2, vis2 = Camera:WorldToViewportPoint(p2.Position) if vis1 and vis2 then local adjustedPos1 = Vector2.new(pos1.X, pos1.Y - guiInset.Y); local adjustedPos2 = Vector2.new(pos2.X, pos2.Y - guiInset.Y); DrawLine(adjustedPos1, adjustedPos2, Skeleton_Color, 1) end end end end; local nameLabel, infoLabel = GetPlayerLabel(player); nameLabel.TextColor3 = Text_Color; infoLabel.TextColor3 = Text_Color; nameLabel.TextSize = ORIGINAL_NAME_SIZE * ESP_TextScale; infoLabel.TextSize = ORIGINAL_INFO_SIZE * ESP_TextScale; if Name_Enabled then nameLabel.Text = player.Name; nameLabel.Position = UDim2.fromOffset(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y - 2); nameLabel.Visible = true end; if InfoBar_Enabled then local health = math.floor((char.Humanoid.Health / char.Humanoid.MaxHealth) * 100); infoLabel.Text = string.format("[ %dm ] [ %d%% ]", distance, health); infoLabel.Position = UDim2.fromOffset(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y + boxSize.Y + 2); infoLabel.Visible = true end; if Tracer_Enabled then local tracerStart = Vector2.new(Camera.ViewportSize.X / 2, 0); local tracerEnd = Vector2.new(boxTopLeft.X + boxSize.X / 2, boxTopLeft.Y); DrawLine(tracerStart, tracerEnd, ESP_Color, 1) end; end; end; end; end) end
end)

VehicleESPConnection = RunService.RenderStepped:Connect(function() if not VehicleESP_Enabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end; local vehiclesFolder = Workspace:FindFirstChild("Vehicles"); if not vehiclesFolder then return end; local localPos = LocalPlayer.Character.HumanoidRootPart.Position; for _, label in pairs(vehicleLabels) do label.Visible = false end; for _, vehicle in ipairs(vehiclesFolder:GetChildren()) do pcall(function() if vehicle:IsA("Model") and vehicle.PrimaryPart then local distance = math.floor((localPos - vehicle.PrimaryPart.Position).Magnitude); if distance <= VehicleESP_MaxDistance then local screenPoint, onScreen = Camera:WorldToViewportPoint(vehicle.PrimaryPart.Position); if onScreen then local label = GetVehicleLabel(vehicle); label.Visible = true; label.TextColor3 = VehicleESP_Color; label.Text = vehicle.Name .. "\n[" .. distance .. "m]"; label.Position = UDim2.fromOffset(screenPoint.X, screenPoint.Y) end end end end) end end)
FullbrightConnection = RunService.RenderStepped:Connect(function() if Fullbright_Enabled then pcall(function() Lighting.Ambient = Color3.fromRGB(200, 200, 200); Lighting.OutdoorAmbient = Color3.fromRGB(200, 200, 200); Lighting.Brightness = 0.5; Lighting.FogEnd = 100000 end) end end)

-- =================================================================================
-- CARREGAMENTO DAS CONFIGURAÃ‡Ã•ES
-- =================================================================================
Rayfield:LoadConfiguration()
print("Script Final por @keven_xz (v1.8) carregado com sucesso!")
